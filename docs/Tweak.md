Maggie Casale & Michelle King

Our Hill Climber Search had these results:

For knapPI_11_20_1000_1 with 100,000 tweaks, we got: 1428, 1160, 1077, 809

For knapPI_13_20_1000_1 with 100,000 tweaks, we got: 1209, 1365, 1209, 1053

For knapPI_16_20_1000_1 with 100,000 tweaks, we got: 2291, 2137, 1798, 1905


Our Hill Climber Search with Rates had these results:

For knapPI_11_20_1000_1 with 100,000 tweaks, we got: 956, 1160, 1160, 190

For knapPI_13_20_1000_1 with 100,000 tweaks, we got: 1287, 1443, 1443, 1521

For knapPI_16_20_1000_1 with 100,000 tweaks, we got: 2090, 1152, 1563, 1563


Our Hill Climber Search with Restarts had these results:

For knapPI_11_20_1000_1 with 100,000 tweaks, we got: 1428, 1428, 1428, 1428

For knapPI_13_20_1000_1 with 100,000 tweaks, we got: 1677, 1638, 1521, 1677

For knapPI_16_20_1000_1 with 100,000 tweaks, we got: 2291, 2137, 1798, 1905


Our Hill Climber Search with Restarts and Rates had these results:

For knapPI_11_20_1000_1 with 100,000 tweaks, we got: 1428, 1428, 1428, 1428

For knapPI_13_20_1000_1 with 100,000 tweaks, we got: 1521, 1677, 1716, 1638

For knapPI_16_20_1000_1 with 100,000 tweaks, we got: 2291, 2291, 2291, 2291


Random Search had these results:

For knapPI_11_20_1000_1 with 100,000 tweaks, we got: 1224, 1428, 1428, 1326

For knapPI_13_20_1000_1 with 100,000 tweaks, we got: 1599, 1599, 1560, 1560

For knapPI_16_20_1000_1 with 100,000 tweaks, we got: 2185, 2126, 2013, 2162

Overarching Comments:
Our Tweaker-with-Rates finds a rate of change for the weight of the knapsack. This results in the tweaker tweaking (hill-climber climbing) at varying rates. This is helpful because as the function approaches a maximum, the slope should be 0 and the rate of change around it will typically be small.
In our hill-search-with-random-restarts we have a counter for the hill-search that counts how many times that the last-best didn't change. Theoretically, as the function reaches the local maximum, the function should stop changing. Once it stops changing more, it is more likely to have reached a local maximum. At this point, the hill-climber will begin again at a random location. This is to increase the probability that the function will have found the global maxima and solved the knapsack problem to the best of its ability.

Hill-Search:
Takes a mutator function (like tweaker, tweaker-with-rates), an instance, and the number of tries it attempts. Our start instance is a random answer generated by random-answer.
From here, we create a loop that initially assigns our "current" as the start instance and assigns the variable "tries" as 0. We do this to print our initial instance so we can see what the initial randomly generated score was. In the loop we check if "tries" is greater than the max number of tries. If so,  the function stops and returns the "current" variable. Else, we check if the score of a tweaked instance is better than the score of "current". If it is, the hill search recurs with the tweaked instance and an increased number of tries. Else, the hill search recurs with the "current" instance and an increased number of tries.

Hill-Search-with-Random-Restart:
Takes a mutator function (like tweaker, tweaker-with-rates), an instance, and the number of tries it attempts. Our start instance is a random answer generated by random-answer. We do this to print our initial instance so we can see what the initial randomly generated score was. Our restart num is the number of items in a knapsack and will be used as the variable to track when to cause a restart. We set this so that the frequency of restarts is connected to the number of items in the knapsack. From here, we create a loop that initially assigns our "current" as the start instance, assigns "last-best" to track the best instance that has occurred so far, assigns the variable "tries" as 0, and sets the variable "counter" as 0. In the loop we check if "tries" is greater than the max number of tries. If so, the function stops and returns the "last-best" variable. Else, we compare our restart-num and counter. If counter is greater than restart-num, we cause a restart to occur. This happens by checking the score of the last-best instance with that of the current instance, the better score of the two is assigned 'last-best' and recurs with a new instance from random-answer and increases the number of tries. Else, we check if the score of a tweaked instance is better than the score of "current". If it is, the hill search recurs with the tweaked instance and an increased number of tries. Else, the hill search recurs with the "current" instance and an increased number of tries.

Tweaker:
Tweaker is a mutating function. It takes in an instance and creates a new instance of either adding (if the knapsack is underweight) or removing (if the knapsack is overweight) an item from ‘:choices’. This item is chosen randomly. 

Tweaker-with-Rates:
Tweaker-with-Rates is another mutating function, it takes an instance. We assign initial as a tweaked instance, this allows us to assign it to current. Here we create a loop for performing tweaks. We use initial to determine the number of tweaks to perform by handing initial and instance (we were handed) to rate-to-tweak. Here we determine which mutation to perform by checking if the instance (we were handed) is over or underweight. 
If overweight, we remove items tweak-num times. Else, its underweight and we add items tweak-num times. We always make an instance of the results from these to update the knapsack.

Rate-to-Tweak:
This takes a tweaked-instance and a current instance. We get the rate or effective slope of search by handing these instances to Rate-It. If the rate is less than .25, we return 1.
If the rate is more than .25 but less than 1, we return 2. Else we return 3.

Rate-It:
This takes a tweaked-instance and a current instance. We find the difference between the two total weights and divide this by the capacity of the knapsack. This gives and effective slope of search, showing us how fast the knapsack is filling/emptying. 

Remove Item:
In ‘remove-item’ we map choices and multiply each element by it’s index (plus one for zero case, and we subtract one from each element after) to create a new vector. That allows us to randomly chose one of these elements without causing a stackoverflow error, and flipping the 1 to a 0 in :choices.

Add Item:
In ‘add-item’ we use the result of ‘remove-item’ and map it with a vector of each element is its index (plus one for zero case, we subtract one from each element after). In this map we remove items from the index vector, which results in only the zero indices from :choices. Like ‘remove-item’, this allows us to randomly chose one of these elements without causing a stackoverflow error, and flipping the 0 to a 1 in :choices.

Make Instance :
In ‘make-instance’ the process from creating an instance in ‘random-answer’ is repeated. Now, we give it our new choices and the instance. This is handed to ‘included-items’, which grabs the appropriate elements from the knapsack; allowing us to recreate elements in the new instance.



